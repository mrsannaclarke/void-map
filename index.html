<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>VOID Tattoo Fest — Booking Map</title>
  <meta name="robots" content="noindex,nofollow">
  <style>
    :root {
      --maxw: 1100px;
      --bg-start: #050816;
      --bg-mid: #14233f;
      --bg-end: #271045;
      --panel-bg: rgba(11, 19, 38, 0.72);
      --panel-inner: rgba(17, 28, 52, 0.65);
      --panel-border: rgba(255, 255, 255, 0.08);
      --chip-border: rgba(255, 255, 255, 0.16);
      --card-shadow: 0 24px 48px rgba(6, 10, 25, 0.55);
      --text-primary: #f4f6ff;
      --text-muted: rgba(244, 246, 255, 0.7);
      --accent: #7cc9ff;
      --accent-strong: #3fa1ff;
    }
    @import url("https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap");
    *,*::before,*::after{box-sizing:border-box}
    html,body{min-height:100%}
    body{
      margin:0;
      font-family:"Montserrat","Segoe UI",Helvetica,Arial,sans-serif;
      background:linear-gradient(135deg,var(--bg-start) 0%,var(--bg-mid) 48%,var(--bg-end) 100%);
      color:var(--text-primary);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:28px;
      padding:36px 18px 54px;
    }
    header{
      width:min(100%,var(--maxw));
      margin:0 auto;
      padding:18px 28px 26px;
      text-align:center;
      background:linear-gradient(160deg,rgba(27,43,73,0.92) 0%,rgba(15,26,48,0.75) 100%);
      border:1px solid var(--panel-border);
      border-radius:26px;
      box-shadow:var(--card-shadow);
      backdrop-filter:blur(14px);
    }
    header h1{
      font-size:28px;
      font-weight:700;
      margin:4px 0 10px;
      letter-spacing:0.04em;
    }
    header p{
      margin:0;
      font-size:15px;
      color:var(--text-muted);
    }
    #void-map-wrap{
      position:relative;
      width:min(100%,var(--maxw));
      margin:0;
      padding:0;
      border-radius:30px;
      border:1px solid var(--panel-border);
      background:radial-gradient(circle at top,rgba(88,155,255,0.22) 0%,rgba(9,16,32,0.9) 60%,rgba(4,8,18,0.95) 100%);
      box-shadow:var(--card-shadow);
      overflow:hidden;
      transition:box-shadow .25s ease,transform .25s ease;
    }
    #void-map-wrap:hover{
      transform:translateY(-4px);
      box-shadow:0 32px 58px rgba(7, 12, 30, 0.6);
    }
    .void-map-layer{display:block;width:100%;height:auto;background:none}
    #void-map{
      position:relative;
      z-index:1;
      background:#ffffff;
    }
    #void-map-top{
      position:absolute;
      inset:0;
      z-index:2;
      pointer-events:none;
      transform:none;
      width:100%;
      height:auto;
      mix-blend-mode:normal;
      opacity:0.94;
    }
    .map-top{
      width:min(100%,var(--maxw));
      display:grid;
      grid-template-columns:repeat(2,minmax(280px,1fr));
      gap:26px;
      align-items:start;
      margin:0 auto;
    }
    .legend{
      width:100%;
      margin:0;
      padding:30px 34px;
      color:var(--text-primary);
      text-align:left;
      background:var(--panel-bg);
      border:1px solid var(--panel-border);
      border-radius:26px;
      box-shadow:var(--card-shadow);
      backdrop-filter:blur(14px);
    }
    .legend h2{font-size:20px;font-weight:600;margin:0 0 16px;text-transform:uppercase;letter-spacing:0.08em;color:var(--accent)}
    .legend-grid{display:flex;flex-direction:column;gap:14px}
    .legend-row{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      border:1px solid var(--panel-border);
      border-radius:18px;
      padding:16px 18px;
      background:var(--panel-inner);
      transition:transform .2s ease,box-shadow .2s ease,border-color .2s ease,background .2s ease;
    }
    .legend-row:hover{
      transform:translateY(-2px);
      box-shadow:0 12px 24px rgba(7,13,26,0.45);
      border-color:rgba(124,201,255,0.4);
      background:rgba(22,36,64,0.82);
    }
    .legend-row.is-active{
      transform:translateY(-2px);
      box-shadow:0 16px 32px rgba(8,14,30,0.55);
      border-color:rgba(124,201,255,0.65);
      background:rgba(28,46,80,0.9);
    }
    .legend-label{
      flex:1 1 220px;
      font-size:15px;
      font-weight:600;
      color:var(--text-primary);
    }
    .legend-swatches{
      display:flex;
      flex:2 1 320px;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .legend-swatch{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      font-weight:500;
      color:var(--text-primary);
      padding:8px 14px;
      border-radius:12px;
      background:rgba(255,255,255,0.06);
      border:1px solid var(--chip-border);
      backdrop-filter:blur(10px);
    }
    .legend-chip{width:18px;height:18px;border-radius:5px;border:1px solid rgba(255,255,255,.25)}
    button.legend-row:focus-visible{outline:2px solid var(--accent);outline-offset:3px}
    .legend-row[data-tag]{cursor:pointer}
    .results-panel{
      width:100%;
      margin:0;
      padding:26px 30px 30px;
      text-align:left;
      background:var(--panel-bg);
      border:1px solid var(--panel-border);
      border-radius:24px;
      box-shadow:var(--card-shadow);
      backdrop-filter:blur(14px);
      color:var(--text-primary);
    }
    .results-panel h2{
      font-size:19px;
      font-weight:600;
      margin:0 0 18px;
      text-transform:uppercase;
      letter-spacing:0.1em;
      color:var(--accent);
    }
    #bookwhen-results{
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    #bookwhen-results p{
      margin:0;
      color:var(--text-muted);
    }
    #bookwhen-results .result{
      padding:14px 16px;
      background:rgba(255,255,255,0.05);
      border:1px solid var(--chip-border);
      border-radius:16px;
      box-shadow:0 10px 24px rgba(9,14,29,0.35);
    }
    #bookwhen-results .result h3{
      margin:0 0 6px;
      font-size:16px;
      font-weight:600;
    }
    #bookwhen-results .result p{
      font-size:13px;
      color:var(--text-muted);
    }
    #bookwhen-results .result a{
      color:var(--accent);
      text-decoration:none;
    }
    #bookwhen-results .result a:hover{
      color:var(--accent-strong);
      text-decoration:underline;
    }
    .note{
      width:min(100%,var(--maxw));
      margin:0 auto;
      padding:18px 24px;
      font-size:14px;
      color:var(--text-muted);
      background:var(--panel-bg);
      border:1px solid var(--panel-border);
      border-radius:22px;
      box-shadow:var(--card-shadow);
      backdrop-filter:blur(14px);
    }
    footer{
      width:min(100%,var(--maxw));
      margin:0 auto;
      padding:16px 22px;
      text-align:center;
      background:var(--panel-bg);
      border:1px solid var(--panel-border);
      border-radius:20px;
      box-shadow:var(--card-shadow);
      backdrop-filter:blur(14px);
      color:var(--text-muted);
    }
    footer small{letter-spacing:0.12em;text-transform:uppercase}
    .hidden{display:none !important}
    .error{color:#ffb4b4}
    a{color:var(--accent);text-decoration:underline}
    a:hover{color:var(--accent-strong)}
    @media (max-width: 900px){
      body{padding:30px 14px 44px;gap:22px}
      .map-top{
        grid-template-columns:1fr;
      }
      .legend,.results-panel{padding:24px}
    }
    @media (max-width: 640px){
      header h1{font-size:24px}
      .legend-row{
        flex-direction:column;
        align-items:flex-start;
        gap:10px;
      }
      .legend-swatches{justify-content:flex-start}
    }
    @media (prefers-reduced-motion: reduce){
      #void-map-wrap,.legend-row,#bookwhen-results .result{transition:none}
    }
  </style>
</head>
<body>
  <div class="map-top">
    <section class="legend" aria-label="Booth legend">
      <h2>Key</h2>
      <div class="legend-grid">
        <button type="button" class="legend-row" data-tag="arium/flex" aria-pressed="false">
          <div class="legend-label">Artist – Jupiter Next – Arium/Flex 10×10 Indoor</div>
          <div class="legend-swatches">
            <div class="legend-swatch"><span class="legend-chip" style="background:#0099ff;"></span>Available</div>
            <div class="legend-swatch"><span class="legend-chip" style="background:#99ccff;"></span>Full</div>
          </div>
        </button>
        <button type="button" class="legend-row" data-tag="dream-tent" aria-pressed="false">
          <div class="legend-label">Artist – Jupiter Original – 10×10 – Dream Tent</div>
          <div class="legend-swatches">
            <div class="legend-swatch"><span class="legend-chip" style="background:#66cccc;"></span>Available</div>
            <div class="legend-swatch"><span class="legend-chip" style="background:#ccffff;"></span>Full</div>
          </div>
        </button>
        <button type="button" class="legend-row" data-tag="small-deluxe-room" aria-pressed="false">
          <div class="legend-label">Artist – Jupiter Original – Small Deluxe Booth</div>
          <div class="legend-swatches">
            <div class="legend-swatch"><span class="legend-chip" style="background:#80c03f;"></span>Available</div>
            <div class="legend-swatch"><span class="legend-chip" style="background:#ccff99;"></span>Full</div>
          </div>
        </button>
        <button type="button" class="legend-row" data-tag="medium-deluxe-room" aria-pressed="false">
          <div class="legend-label">Artist – Jupiter Original – Medium Deluxe Booth</div>
          <div class="legend-swatches">
            <div class="legend-swatch"><span class="legend-chip" style="background:#ff3399;"></span>Available</div>
            <div class="legend-swatch"><span class="legend-chip" style="background:#ffcccc;"></span>Full</div>
          </div>
        </button>
        <button type="button" class="legend-row" data-tag="large-deluxe-room" aria-pressed="false">
          <div class="legend-label">Artist – Jupiter Original – Large Deluxe Booth</div>
          <div class="legend-swatches">
            <div class="legend-swatch"><span class="legend-chip" style="background:#9393f7;"></span>Available</div>
            <div class="legend-swatch"><span class="legend-chip" style="background:#ccccff;"></span>Full</div>
          </div>
        </button>
        <button type="button" class="legend-row" data-tag="vendor" aria-pressed="false">
          <div class="legend-label">Vendor</div>
          <div class="legend-swatches">
            <div class="legend-swatch"><span class="legend-chip" style="background:#e97d13;"></span>Available</div>
            <div class="legend-swatch"><span class="legend-chip" style="background:#ed9c4d;"></span>Full</div>
          </div>
        </button>
        <button type="button" class="legend-row" data-tag="street-fair" aria-pressed="false">
          <div class="legend-label">Street Fair Vendor – Saturday Only</div>
          <div class="legend-swatches">
            <div class="legend-swatch"><span class="legend-chip" style="background:#cc0000;"></span>Available</div>
            <div class="legend-swatch"><span class="legend-chip" style="background:#ff9999;"></span>Full</div>
          </div>
        </button>
        <div class="legend-row" aria-hidden="true">
          <div class="legend-label">Wayfinding</div>
          <div class="legend-swatches">
            <div class="legend-swatch"><span class="legend-chip" style="background:#ffff00;"></span>Exits</div>
            <div class="legend-swatch"><span class="legend-chip" style="background:#4001be;"></span>Restrooms</div>
            <div class="legend-swatch"><span class="legend-chip" style="background:#c59900;"></span>VOID Activities</div>
            <div class="legend-swatch"><span class="legend-chip" style="background:#466154;"></span>"Hey Love" Bar &amp; Restaurant</div>
          </div>
        </div>
      </div>
    </section>
    <section class="results-panel" id="bookwhen-panel" aria-label="Bookwhen filtered results">
      <h2>Matching Entries</h2>
      <div id="bookwhen-results" aria-live="polite">Select a booth category to see matching bookings.</div>
    </section>
  </div>

  <div id="status" class="note" role="status" aria-live="polite">Loading map…</div>

  <div id="void-map-wrap" aria-label="VOID Booking Map">
    <object id="void-map" class="void-map-layer" type="image/svg+xml" data="" aria-label="Interactive booth map"></object>
    <img id="void-map-top" class="void-map-layer" src="" alt="Wayfinding overlay (exits, food, restrooms, outlines)">
    <noscript>Please enable JavaScript to view the booking map.</noscript>
  </div>

  <script>
  (function () {
    // Host the assets in the SAME folder as this HTML for best results (same-origin access)
    // If you prefer a CDN path, set the three URLs to absolute HTTPS paths from the same origin.
    // HALF-MAP asset targets
    const MAP_CONFIG_URL = "./halfmap_config.json";            // New pruned config for the half map
    const SVG_URL        = "./halfmapvoidjupiterbookingmap.svg"; // Half-map SVG (centered version)
    const PNG_OVERLAY_URL= "./overlayhalfmap.png";             // Half-map transparent overlay

    const obj = document.getElementById("void-map");
    const overlay = document.getElementById("void-map-top");
    const statusEl = document.getElementById("status");
    const svgNS = "http://www.w3.org/2000/svg";
    const xlinkNS = "http://www.w3.org/1999/xlink";
    let latestConfig = null;

    function chooseTextColor(hex) {
      if (!hex) return "#111111";
      let value = hex.replace("#", "").trim();
      if (value.length === 3) value = value.split("").map(ch => ch + ch).join("");
      const r = parseInt(value.slice(0, 2), 16);
      const g = parseInt(value.slice(2, 4), 16);
      const b = parseInt(value.slice(4, 6), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness < 140 ? "#ffffff" : "#111111";
    }

    function lightenColor(hex, amount = 0.18) {
      if (!hex) return "#777777";
      let value = hex.replace("#", "").trim();
      if (value.length === 3) value = value.split("").map(ch => ch + ch).join("");
      const clamp = v => Math.max(0, Math.min(255, v));
      const mix = val => clamp(Math.round(val + (255 - val) * amount));
      const r = parseInt(value.slice(0, 2), 16);
      const g = parseInt(value.slice(2, 4), 16);
      const b = parseInt(value.slice(4, 6), 16);
      return "#" + [mix(r), mix(g), mix(b)].map(v => v.toString(16).padStart(2, "0")).join("").toUpperCase();
    }

    function computeFontSize(label, bbox) {
      const textLength = Math.max(label.length, 1);
      const widthBased = bbox.width / textLength * 1.8;
      const heightBased = bbox.height * 0.75;
      let rawSize = Math.min(widthBased, heightBased);
      if (label.length === 1 && /[KLMN]/i.test(label)) {
        rawSize = rawSize * 0.85;
      }
      return Math.max(7, Math.min(36, rawSize));
    }

    function ensureLabelLayer(doc) {
      const existing = doc.getElementById("void-label-layer");
      if (existing) return existing;
      const layer = doc.createElementNS(svgNS, "g");
      layer.setAttribute("id", "void-label-layer");
      layer.setAttribute("class", "void-label-layer");
      layer.setAttribute("aria-hidden", "true");
      layer.style.pointerEvents = "none";
      layer.style.fontFamily = "inherit";
      const svgRoot = doc.documentElement;
      svgRoot.appendChild(layer);
      return layer;
    }

    function wrapWithLink(pathEl, href) {
      if (!pathEl || !href) return null;
      const parent = pathEl.parentNode;
      if (parent && parent.nodeName.toLowerCase() === "a") {
        parent.setAttributeNS(xlinkNS, "xlink:href", href);
        parent.setAttribute("target", "_blank");
        parent.setAttribute("rel", "noopener noreferrer");
        return parent;
      }
      const anchor = pathEl.ownerDocument.createElementNS(svgNS, "a");
      anchor.setAttributeNS(xlinkNS, "xlink:href", href);
      anchor.setAttribute("target", "_blank");
      anchor.setAttribute("rel", "noopener noreferrer");
      if (parent) {
        parent.replaceChild(anchor, pathEl);
      }
      anchor.appendChild(pathEl);
      return anchor;
    }

    function decorateShape(id, data) {
      if (!id || !data) return;
      const doc = obj.contentDocument;
      if (!doc) return;
      const svgEl = doc.getElementById(id);
      if (!svgEl) return;
      const labelText = (data.label || "").toString().trim();
      const link = data.link;
      if (!labelText || !link) return;

      const textColor = "#111111";
      const outlineColor = "#ffffff";

      svgEl.setAttribute("fill", data.color || "#666666");
      svgEl.style.fill = data.color || "#666666";
      if (data.color) {
        svgEl.style.stroke = outlineColor;
        svgEl.style.strokeWidth = "1.5";
        svgEl.style.strokeOpacity = "0.85";
      }
      svgEl.style.cursor = "pointer";
      svgEl.setAttribute("data-void-label", labelText);
      svgEl.setAttribute("data-void-link", link);

      const anchorEl = wrapWithLink(svgEl, link) || svgEl;

      let bbox;
      try {
        bbox = svgEl.getBBox();
      } catch (err) {
        return;
      }
      if (!bbox || !bbox.width || !bbox.height) return;

      const labelLayer = ensureLabelLayer(obj.contentDocument);
      const textEl = obj.contentDocument.createElementNS(svgNS, "text");
      const fontSize = computeFontSize(labelText, bbox);
      const fill = textColor;
      const outline = outlineColor;
      const strokeWidth = Math.max(0.8, fontSize * 0.18);

      textEl.textContent = labelText;
      textEl.setAttribute("x", (bbox.x + bbox.width / 2).toFixed(2));
      textEl.setAttribute("y", (bbox.y + bbox.height / 2).toFixed(2));
      textEl.setAttribute("text-anchor", "middle");
      textEl.setAttribute("dominant-baseline", "middle");
      textEl.setAttribute("font-weight", "700");
      textEl.setAttribute("font-size", fontSize.toFixed(2));
      textEl.setAttribute("fill", fill);
      textEl.setAttribute("data-booth-id", id);
      textEl.style.pointerEvents = "none";
      textEl.style.paintOrder = "stroke";
      textEl.style.stroke = outline;
      textEl.style.strokeWidth = strokeWidth.toFixed(2);
      textEl.style.strokeOpacity = "0.85";

      labelLayer.appendChild(textEl);

      const hoverTarget = anchorEl.nodeName.toLowerCase() === "a" ? anchorEl : svgEl;
      const hoverPath = svgEl;
      const hoverFill = lightenColor(data.color || "#666666", 0.22);
      hoverTarget.onmouseenter = () => {
        hoverPath.style.fill = hoverFill;
        hoverPath.style.filter = "drop-shadow(0 0 6px rgba(0,0,0,0.25))";
        hoverPath.style.strokeWidth = "2";
        textEl.style.filter = "drop-shadow(0 0 4px rgba(0,0,0,0.25))";
      };
      hoverTarget.onmouseleave = () => {
        hoverPath.style.fill = data.color || "#666666";
        hoverPath.style.filter = "";
        hoverPath.style.strokeWidth = "1.5";
        textEl.style.filter = "";
      };
    }

    function applyConfig(cfg) {
      latestConfig = cfg;
      const doc = obj.contentDocument;
      if (!doc) {
        console.warn("[map] SVG document not ready for config application");
        return;
      }
      ensureLabelLayer(doc); // make sure layer exists even if there are no paths yet
      const labelLayer = doc.getElementById("void-label-layer");
      while (labelLayer.firstChild) {
        labelLayer.removeChild(labelLayer.firstChild);
      }
      const paths = (cfg && cfg.paths) ? cfg.paths : {};
      Object.keys(paths).forEach(id => decorateShape(id, paths[id]));
    }

    // Utility
    function setStatus(msg, isError){
      if(!statusEl) return;
      statusEl.textContent = msg;
      statusEl.classList.toggle("error", !!isError);
    }

    // 1) Set overlay image
    overlay.src = PNG_OVERLAY_URL;

    // 2) When the SVG loads, fetch and expose config
    obj.addEventListener("load", function(){
      console.log("[map] SVG object loaded");
      // Try to set a reference inside the embedded SVG (works only if same-origin)
      let svgWin = null;
      try { svgWin = obj.contentWindow || null; } catch(e) {}

      fetch(MAP_CONFIG_URL, { cache: "no-cache" })
        .then(r => {
          if(!r.ok) throw new Error("Config fetch failed: " + r.status);
          return r.json();
        })
        .then(cfg => {
          console.log("[map] Config fetched", cfg);
          // Expose to parent window
          window.VOID_MAP_CONFIG = cfg;

          // Pass to SVG via same-origin reference
          try {
            if (svgWin) svgWin.VOID_MAP_CONFIG = cfg;
          } catch(e) { /* cross-origin, ignore */ }

          // Also broadcast via postMessage in case the SVG listens for it
          try {
            if (svgWin && typeof svgWin.postMessage === "function") {
              svgWin.postMessage({type:"VOID_MAP_CONFIG", payload: cfg}, "*");
            }
          } catch(e) {}

          applyConfig(cfg);
          setStatus("Map loaded.");
          if (statusEl) setTimeout(() => statusEl.classList.add("hidden"), 800);
        })
        .catch(err => {
          console.warn("[map] Could not fetch map config; showing base SVG only.", err);
        });
    });

    // 3) Kick off the SVG load AFTER we attach listeners
    obj.addEventListener("load", function(){
      if (latestConfig) applyConfig(latestConfig);
    }, { once: false });

    obj.data = SVG_URL;

    // 4) Basic network sanity checks (optional)
    function ping(url){
      return fetch(url, {method:"HEAD"}).then(r => r.ok).catch(() => false);
    }
    Promise.all([ping(SVG_URL), ping(MAP_CONFIG_URL), ping(PNG_OVERLAY_URL)]).then(([okSvg, okJson, okPng]) => {
      if(!okSvg) setStatus("SVG not found: " + SVG_URL, true);
      else if(!okJson) setStatus("Config not found: " + MAP_CONFIG_URL + " (map can still render)", true);
      else if(!okPng) setStatus("Overlay not found: " + PNG_OVERLAY_URL + " (optional)", true);
    });
  })();
  </script>

  <script>
  (function(){
    const legendButtons = Array.from(document.querySelectorAll('.legend button.legend-row[data-tag]'));
    const resultsBox = document.getElementById('bookwhen-results');
    if (!legendButtons.length || !resultsBox) return;

    const BOOKWHEN_CALENDAR = "dxai1grkiqrc";
    const BOOKWHEN_TOKEN = "rt45bufbvgoig1mzrlo9fm8e1zw9"; // Read-only; replace at runtime if needed.

    const API_ROOT = "https://api.bookwhen.com/v2/events";
    const escapeHtml = str => (str || "").replace(/[&<>"']/g, ch => (
      { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[ch] || ch
    ));
    const norm = s => (s || "").toString().trim().toLowerCase().replace(/\s+/g, "-");
    const variants = s => {
      const base = norm(s);
      return new Set([ base, base.replace(/\//g, "-"), base.replace(/\//g, "") ]);
    };

    function formatWhen(iso){
      if (!iso) return "";
      try {
        return new Date(iso).toLocaleString(undefined, {
          dateStyle: "medium",
          timeStyle: "short"
        });
      } catch (err) {
        return iso;
      }
    }

    function setActiveButton(active){
      legendButtons.forEach(btn => {
        const isActive = btn === active;
        btn.classList.toggle("is-active", isActive);
        btn.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
    }

    async function loadBookwhenByTag(tag){
      const label = tag || "";
      if (!BOOKWHEN_TOKEN) {
        resultsBox.innerHTML = '<p class="error">Missing Bookwhen token.</p>';
        return;
      }
      resultsBox.innerHTML = `<p>Loading “${escapeHtml(label)}”&hellip;</p>`;

      const url = new URL(API_ROOT);
      url.searchParams.set("calendar", BOOKWHEN_CALENDAR);
      url.searchParams.set("include", "tags");
      url.searchParams.set("page[size]", "100");

      try {
        const response = await fetch(url.toString(), {
          method: "GET",
          mode: "cors",
          headers: {
            "Authorization": "Basic " + btoa(BOOKWHEN_TOKEN + ":"),
            "Accept": "application/json"
          }
        });
        if (!response.ok) {
          const detail = `${response.status} ${response.statusText || ""}`.trim();
          throw Object.assign(new Error("HTTP " + detail), { status: response.status });
        }
        const payload = await response.json();

        const tagIndex = new Map();
        (payload.included || []).forEach(item => {
          if (item && item.type === "tags") {
            const slug = item.attributes?.slug || "";
            const name = item.attributes?.name || "";
            tagIndex.set(item.id, { slug, name });
          }
        });

        const desired = variants(label);
        const expandTag = val => {
          const normalized = norm(val);
          return [
            normalized,
            normalized.replace(/\//g, "-"),
            normalized.replace(/\//g, "")
          ];
        };

        const events = (payload.data || []).filter(evt => {
          const related = evt.relationships?.tags?.data || [];
          const collected = [];
          related.forEach(ref => {
            const entry = tagIndex.get(ref.id);
            if (entry) collected.push(entry.slug || entry.name);
          });
          const attributes = evt.attributes || {};
          ["tags", "tag_list", "labels"].forEach(key => {
            const val = attributes[key];
            if (Array.isArray(val)) collected.push(...val);
            else if (typeof val === "string" && val) {
              collected.push(...val.split(",").map(v => v.trim()));
            }
          });

          const normalized = new Set(collected.flatMap(expandTag));
          for (const want of desired) if (normalized.has(want)) return true;
          return false;
        });

        if (!events.length) {
          resultsBox.innerHTML = `<p>No matching entries for “${escapeHtml(label)}”.</p>`;
          return;
        }

        const list = events.map(evt => {
          const attrs = evt.attributes || {};
          const title = escapeHtml(attrs.title || "Untitled entry");
          const when = escapeHtml(formatWhen(attrs.start_at));
          const venue = attrs.location?.name ? ` • ${escapeHtml(attrs.location.name)}` : "";
          const href = escapeHtml((evt.links?.public || evt.links?.self || "#").toString());
          return `<article class="result"><h3><a href="${href}" target="_blank" rel="noopener">${title}</a></h3><p>${when}${venue}</p></article>`;
        });

        resultsBox.innerHTML = `<p><strong>${events.length}</strong> result(s) for “${escapeHtml(label)}”.</p>` + list.join("");
      } catch (err) {
        console.warn("[bookwhen] fetch failed", err);
        const statusMsg = err && err.status ? ` (status ${err.status})` : "";
        const advice = err && err.status === 401
          ? " Check that the read-only token is still valid and has API access."
          : " Verify network connectivity and that the page is served over HTTPS.";
        resultsBox.innerHTML = `<p class="error">Failed to load entries from Bookwhen${statusMsg}.${advice}</p>`;
      }
    }

    legendButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        const tag = btn.dataset.tag || "";
        setActiveButton(btn);
        loadBookwhenByTag(tag);
      });
    });
  })();
  </script>
</body>
</html>
