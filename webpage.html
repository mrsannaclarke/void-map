<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Jupiter Void Map Overlay</title>
  <style>
    :root {
      --map-ratio: 0.3225;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: #ffffff;
      font-family: "Montserrat", "Arial", sans-serif;
    }

    .map-shell {
      width: 100%;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: #ffffff;
    }

    .map-stage {
      margin: 0;
      position: relative;
      width: min(100%, calc((100vh - 32px) * var(--map-ratio)));
      aspect-ratio: var(--map-ratio);
      max-height: calc(100vh - 32px);
    }

    @media (max-height: 520px) {
      .map-stage {
        max-height: calc(100vh - 16px);
        width: min(100%, calc((100vh - 16px) * var(--map-ratio)));
      }
    }

    .map-stage img,
    .map-stage object,
    .map-stage .svg-layer {
      display: block;
    }

    #map-base {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .svg-layer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #svg-root svg,
    #svg-root-back svg,
    #svg-fallback {
      width: 100%;
      height: 100%;
    }

    .shape-label {
      fill: #ffffff;
      stroke: #000000;
      stroke-width: 1px;
      paint-order: stroke fill;
      font-family: "Montserrat", "Arial", sans-serif;
      font-weight: 800;
      letter-spacing: 0.02em;
      pointer-events: none;
      text-shadow:
        0 1px 0 rgba(0, 0, 0, 0.25),
        0 -1px 0 rgba(0, 0, 0, 0.25),
        1px 0 0 rgba(0, 0, 0, 0.25),
        -1px 0 0 rgba(0, 0, 0, 0.25);
    }
  </style>
</head>
<body>
  <main class="map-shell">
    <figure class="map-stage" role="presentation">
      <div id="svg-root-back" class="svg-layer" aria-hidden="true"></div>
      <img src="jupiter.png" alt="Jupiter Void floor map" id="map-base">
      <object id="svg-fallback" class="svg-layer" data="jupitermapv1.svg" type="image/svg+xml" aria-hidden="true"></object>
      <div id="svg-root" class="svg-layer"></div>
    </figure>
  </main>

  <script>
    (() => {
      const SVG_NS = "http://www.w3.org/2000/svg";
      const SVG_URL = "jupitermapv1.svg";
      const DATA_URL = "jupitervoid.json";
      const MAX_LABEL_FONT_PX = 5;
      const MIN_LABEL_FONT_PX = 4;
      const PRESERVE_COLOR = new Set([
        "_9thst", "arium", "bunker", "command", "dreambox", "dreamtentroof",
        "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "e10", "e11", "sb", "stage", "thinktank"
      ]);
      const INACTIVE_SHAPES = new Set(["ina", "ina1", "ina2"]);
      const ROTATE_LEFT_90 = new Set(["ankeny", "burnside"]);
      const WAYFINDING_MATCHERS = [
        /^(?:Bunker)$/i,
        /^9th\s+Street\b.*Street\s+Fair$/i,
        /^Dream\s*Tent\s*Roof$/i,
        /^(?:Stage)$/i,
        /^Dream\s*Box$/i,
        /^Think\s*Tank$/i,
        /^Command\s*Center$/i
      ];
      const WAYFINDING_SHRINK_SPEC = [
        { rx: /^(?:Stage)$/i, fs: 4.2 },
        { rx: /^Dream\s*Box$/i, fs: 2 },
        { rx: /^Think\s*Tank$/i, fs: 2 },
        { rx: /^Command\s*Center$/i, fs: 2 },
        { rx: /^Dream\s*Tent\s*Roof$/i, fs: 4.2 },
        { rx: /^9th\s+Street\b.*Street\s+Fair$/i, fs: 4.0 },
        { rx: /^(?:Bunker)$/i, fs: 4.2 }
      ];
      const CUSTOM_LABEL_MAP = new Map([
        ["arium", "Arium"],
        ["heylovebar", "Hey Love Bar\n&\nSecret Garden\nPatio"],
        ["elevators", "Elevators"],
        ["restrooms", "Restrooms"],
        ["dreamtentroof", "Dream Tent\nRoof"],
        ["jupiteroglv1", "Jupiter Original - Level 1"],
        ["jupiteroglv2", "Jupiter Original - Level 2"],
        ["jnextlv2", "Jupiter Next - Level 2"],
        ["flexlounge", "Flex Lounge"],
        ["sb", "SB"],
        ["stage", "Stage"],
        ["bunker", "Bunker"],
        ["dreambox", "Dream\nBox"],
        ["thinktank", "Think\nTank"],
        ["command", "Command\nCenter"],
        ["_9thst", "9th Street - Street Fair - Saturday Only"],
        ["rr1", "R"],
        ["ankeny", "Ankeny"],
        ["burnside", "Burnside"]
      ]);

      const svgHostBack = document.getElementById("svg-root-back");
      const svgHost = document.getElementById("svg-root");
      const svgFallback = document.getElementById("svg-fallback");

      const cssEscape = window.CSS && window.CSS.escape
        ? window.CSS.escape.bind(window.CSS)
        : (value) => String(value || "").replace(/([.*+?^${}()|[\]\\])/g, "\\$1");

      Promise.all([
        fetch(SVG_URL).then((res) => {
          if (!res.ok) throw new Error("Unable to load SVG overlay");
          return res.text();
        }),
        fetch(DATA_URL).then((res) => {
          if (!res.ok) throw new Error("Unable to load map data");
          return res.json();
        })
      ])
        .then(([svgMarkup, mapData]) => {
          const parser = new DOMParser();
          const svgDocument = parser.parseFromString(svgMarkup, "image/svg+xml");
          const baseSvg = svgDocument.documentElement;
          const frontSvg = baseSvg.cloneNode(true);
          const backSvg = baseSvg.cloneNode(true);

          splitSvgLayers(frontSvg, backSvg);

          frontSvg.id = "map-svg";
          backSvg.id = "map-svg-back";

          if (svgHostBack) svgHostBack.appendChild(backSvg);
          if (svgHost) svgHost.appendChild(frontSvg);
          if (svgFallback) svgFallback.style.display = "none";

          ensureLabelLayer(frontSvg);
          tweakNativeLabels(frontSvg);
          applyMapData(frontSvg, mapData || {});
          matchVisualLabelSize(frontSvg, "131");
          addCustomOverlayLabels(frontSvg);
        })
        .catch((error) => {
          console.error(error);
          if (svgFallback) svgFallback.style.display = "block";
        });

      function ensureLabelLayer(svgRoot) {
        if (!svgRoot) return null;
        let layer = svgRoot.querySelector("#label-layer");
        if (!layer) {
          layer = document.createElementNS(SVG_NS, "g");
          layer.setAttribute("id", "label-layer");
          svgRoot.appendChild(layer);
        }
        return layer;
      }

      function splitSvgLayers(frontSvg, backSvg) {
        const idsToBack = ["e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "e10", "e11"];
        idsToBack.forEach((id) => {
          const node = frontSvg.querySelector("#" + cssEscape(id));
          if (node && node.parentNode) {
            node.parentNode.removeChild(node);
          }
        });
        const nodesToMove = idsToBack
          .map((id) => backSvg.querySelector("#" + cssEscape(id)))
          .filter(Boolean);
        let backLayer = backSvg.querySelector("#back-layer");
        if (!backLayer) {
          backLayer = document.createElementNS(SVG_NS, "g");
          backLayer.setAttribute("id", "back-layer");
          backSvg.appendChild(backLayer);
        }
        nodesToMove.forEach((node) => {
          if (node.parentNode) node.parentNode.removeChild(node);
          backLayer.appendChild(node);
        });
        Array.from(backSvg.children).forEach((child) => {
          if (child === backLayer) return;
          const tag = (child.tagName || "").toLowerCase();
          if (tag === "defs" || tag.endsWith(":defs")) return;
          if (tag === "style" || tag.endsWith(":style")) return;
          if (child.parentNode === backSvg) backSvg.removeChild(child);
        });
      }

      function findShapeNode(svgElement, canonicalName) {
        if (!canonicalName) return null;
        let node = svgElement.querySelector("#" + cssEscape(canonicalName));
        if (node) return node;
        node = svgElement.querySelector("#_" + cssEscape(canonicalName));
        if (node) return node;
        node = svgElement.querySelector('[data-name="' + cssEscape(canonicalName) + '"]');
        if (node) return node;
        node = svgElement.querySelector('[id$="-' + cssEscape(canonicalName) + '"]');
        if (node) return node;
        if (/^\d+$/.test(canonicalName)) {
          const prefixes = ["sf", "dt", "booth", "b", "a"];
          for (const prefix of prefixes) {
            node = svgElement.querySelector("#" + cssEscape(prefix + canonicalName));
            if (node) return node;
            node = svgElement.querySelector("#_" + cssEscape(prefix + canonicalName));
            if (node) return node;
            node = svgElement.querySelector('[data-name="' + cssEscape(prefix + canonicalName) + '"]');
            if (node) return node;
            node = svgElement.querySelector('[id$="-' + cssEscape(prefix + canonicalName) + '"]');
            if (node) return node;
          }
        }
        return null;
      }

      function normalizeLabel(raw) {
        const value = String(raw || "").trim();
        if (/^([a-z])\1?$/i.test(value)) return value.toUpperCase();
        let match = value.match(/^_?(?:sf|s)[-_]?(\d+)$/i);
        if (match) return String(parseInt(match[1], 10));
        if (/^[hn][-_]?1$/i.test(value)) return value.charAt(0).toUpperCase();
        match = value.match(/^([a-z]+)(\d+)$/i);
        if (match) {
          const letters = match[1].toLowerCase();
          const digits = match[2];
          if (letters === "a") return String(parseInt(digits, 10));
          if (digits === "1") return match[1].toUpperCase();
          return String(parseInt(digits, 10));
        }
        return value;
      }

      function applyMapData(svgElement, mapData) {
        const shapes = mapData && mapData.shapes ? mapData.shapes : {};
        for (const [shapeName, payload] of Object.entries(shapes)) {
          const canonicalName = String(shapeName).replace(/^_+/, "");
          if (INACTIVE_SHAPES.has(canonicalName)) continue;
          const elementId =
            (payload.svg && payload.svg.id) ||
            (payload.svg && payload.svg.resolved_from) ||
            shapeName;
          let target = findShapeNode(svgElement, canonicalName);
          if (!target && elementId) {
            const resolved = String(elementId).replace(/^_+/, "");
            target = findShapeNode(svgElement, resolved);
          }
          if (!target) continue;
          decorateShape(target, canonicalName, payload, mapData);
        }

        const jsonShapeKeys = new Set(
          Object.keys(shapes).map((key) => String(key).replace(/^_+/, ""))
        );

        jsonShapeKeys.forEach((canonicalId) => {
          if (INACTIVE_SHAPES.has(canonicalId)) return;
          const node = findShapeNode(svgElement, canonicalId);
          if (node && !node.classList.contains("no-interaction")) {
            appendLabel(node, normalizeLabel(canonicalId), canonicalId);
          }
        });

        ensureNumericSvgLabels(svgElement, jsonShapeKeys);
        labelStreetFairNodes(svgElement);
      }

      function decorateShape(node, label, payload, mapData) {
        node.setAttribute("data-shape", label);
        const boothName = payload && payload.csv && payload.csv.booth_name
          ? String(payload.csv.booth_name)
          : `Shape ${label}`;
        node.setAttribute("aria-label", `${boothName} (${label})`);
        if (!node.querySelector("title")) {
          const title = document.createElementNS(SVG_NS, "title");
          title.textContent = `${boothName} (${label})`;
          node.appendChild(title);
        }

        const keepOriginal = shouldPreserveFill(node, label);
        if (keepOriginal) {
          node.style.removeProperty("fill");
        } else if (payload && payload.color) {
          try { node.style.fill = payload.color; } catch (_) {}
        } else if (payload && payload.status) {
          const colors = { available: "#6BB5FF", partial: "#FFB84D", full: "#A0A0A0" };
          const color = colors[String(payload.status).toLowerCase()];
          if (color) {
            try { node.style.fill = color; } catch (_) {}
          } else {
            node.style.removeProperty("fill");
          }
        } else {
          node.style.removeProperty("fill");
        }

        const displayLabel = normalizeLabel((payload && payload.label) ? payload.label : label);
        appendLabel(node, displayLabel, label);

        const published = isPublishedKey_(mapData, label);
        if (!published) {
          node.setAttribute("data-unpublished", "true");
          if (!keepOriginal) {
            try { node.style.fill = "#999999"; } catch (_) {}
          }
        } else {
          node.removeAttribute("data-unpublished");
        }

        node.classList.remove("shape-interactive");
        node.removeAttribute("tabindex");
        node.removeAttribute("role");
        node.style.pointerEvents = "none";
        node.style.cursor = "default";
      }

      function shouldPreserveFill(node, label) {
        const nodeId = (node && node.id) ? node.id : "";
        const key = String(label || "").replace(/^_+/, "");
        return (
          node.classList.contains("label-box") ||
          node.classList.contains("no-interaction") ||
          PRESERVE_COLOR.has(nodeId) ||
          PRESERVE_COLOR.has(key)
        );
      }

      function ensureNumericSvgLabels(svgElement, jsonShapeKeys) {
        const svg = svgElement.ownerSVGElement || svgElement;
        const labelLayer = svg.querySelector("#label-layer");
        const hasLabelFor = (key) =>
          labelLayer && labelLayer.querySelector(`text[data-shape-key="${cssEscape(key)}"]`);
        const candidates = Array.from(svg.querySelectorAll("[id], [data-name]"));
        candidates.forEach((el) => {
          const rawId = (el.getAttribute("id") || el.getAttribute("data-name") || "").trim();
          if (!rawId) return;
          const match = rawId.match(/^_?(\d{3})$/);
          if (!match) return;
          const roomKey = match[1];
          if (INACTIVE_SHAPES.has(roomKey)) return;
          if (jsonShapeKeys.has(roomKey)) return;
          if (el.classList && el.classList.contains("no-interaction")) return;
          if (hasLabelFor(roomKey)) return;
          appendLabel(el, roomKey, roomKey);
        });
      }

      function labelStreetFairNodes(svgElement) {
        const svg = svgElement.ownerSVGElement || svgElement;
        const nodes = svg.querySelectorAll(
          '[id^="sf"], [id^="SF"], [id^="_sf"], [id^="_SF"], [data-name^="sf"], [data-name^="SF"], [id^="s"], [id^="_s"], [data-name^="s"]'
        );
        nodes.forEach((node) => {
          if (node.getAttribute("data-no-label") === "true") return;
          const idLike = (node.getAttribute("id") || node.getAttribute("data-name") || "").trim();
          if (!idLike) return;
          const match = idLike.match(/_?(?:sf|s)[-_]?(\d+)/i);
          if (!match) return;
          const num = match[1];
          const key = node.getAttribute("data-shape") || `sf${num}`;
          const svgRoot = node.ownerSVGElement || node.closest("svg");
          const layer = svgRoot && svgRoot.querySelector("#label-layer");
          const hasExisting = layer && layer.querySelector(`text[data-shape-key="${cssEscape(key)}"]`);
          if (hasExisting) return;
          appendLabel(node, num, key);
          if (layer) {
            const t = layer.querySelector(`text[data-shape-key="${cssEscape(key)}"]`);
            if (t) {
              const current = parseFloat(t.getAttribute("font-size") || "0");
              if (current < 7) t.setAttribute("font-size", "7");
            }
          }
        });
      }

      function isPublishedKey_(mapData, key) {
        try {
          const k = String(key || "").trim();
          if (!k) return false;
          const published = mapData && Array.isArray(mapData.published) ? new Set(mapData.published.map(String)) : null;
          const unpublished = mapData && Array.isArray(mapData.unpublished) ? new Set(mapData.unpublished.map(String)) : null;
          if (published) return published.has(k);
          if (unpublished) return !unpublished.has(k);
          return true;
        } catch (_) {
          return true;
        }
      }

      function appendLabel(node, label, shapeKey) {
        const textValue = String(label).replace(/^_+/, "");
        const key = shapeKey || node.getAttribute("data-shape") || textValue;
        if (node.getAttribute("data-no-label") === "true") return;
        if (node.querySelector("text, tspan")) return;
        const bbox = node.getBBox();
        const cx = bbox.x + bbox.width / 2;
        const cy = bbox.y + bbox.height / 2;
        const byHeight = bbox.height * 0.55;
        const byWidthPerChar = (bbox.width / Math.max(1, textValue.length)) * 0.9;
        const fsCandidate = Math.min(byHeight, byWidthPerChar);
        let boost = 1;
        if (/^[a-z]{1,2}$/i.test(textValue)) boost = Math.max(boost, 1.20);
        if (/^\d+$/.test(textValue)) {
          const n = parseInt(textValue, 10);
          if (!isNaN(n) && n <= 13) boost = Math.max(boost, 1.15);
        }
        let localMax = MAX_LABEL_FONT_PX;
        if (/^[a-z]{1,2}$/i.test(textValue)) localMax = Math.max(localMax, 6.5);
        if (/^\d+$/.test(textValue) && parseInt(textValue, 10) <= 13) localMax = Math.max(localMax, 6.0);
        const boosted = fsCandidate * boost;
        const fs = Math.max(MIN_LABEL_FONT_PX, Math.min(localMax, boosted));
        const text = document.createElementNS(SVG_NS, "text");
        text.classList.add("shape-label");
        text.setAttribute("x", cx.toFixed(2));
        text.setAttribute("y", cy.toFixed(2));
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("dominant-baseline", "middle");
        text.setAttribute("data-shape-label", textValue);
        text.setAttribute("data-shape-key", key);
        text.setAttribute("font-size", fs.toFixed(2));
        text.textContent = textValue;
        if (ROTATE_LEFT_90.has(String(shapeKey || "").replace(/^_+/, ""))) {
          text.setAttribute("transform", `rotate(-90 ${cx.toFixed(2)} ${cy.toFixed(2)})`);
        }
        const svgRoot = node.ownerSVGElement || node.closest("svg");
        let layer = svgRoot.querySelector("#label-layer");
        if (!layer) {
          layer = document.createElementNS(SVG_NS, "g");
          layer.setAttribute("id", "label-layer");
          svgRoot.appendChild(layer);
        }
        const existing = layer.querySelector(`text[data-shape-key="${cssEscape(key)}"]`);
        if (existing) existing.remove();
        layer.appendChild(text);
      }

      function tweakNativeLabels(svg) {
        const arium = svg.querySelector("#arium");
        if (arium) {
          arium.querySelectorAll("rect, path, polygon, polyline, circle, ellipse").forEach((el) => {
            el.style.fill = "transparent";
            el.style.stroke = "transparent";
            el.removeAttribute("fill");
            el.removeAttribute("stroke");
          });
        }
        ["ankeny", "burnside"].forEach((id) => {
          const node = svg.querySelector("#" + cssEscape(id));
          if (!node) return;
          node.querySelectorAll("rect, path, polygon, polyline, circle, ellipse").forEach((el) => {
            el.style.stroke = "transparent";
            el.removeAttribute("stroke");
          });
        });
        svg.querySelectorAll("text").forEach((text) => {
          const content = (text.textContent || "").trim();
          if (!content) return;
          if (WAYFINDING_MATCHERS.some((rx) => rx.test(content))) {
            const current = parseFloat(text.getAttribute("font-size") || window.getComputedStyle(text).fontSize);
            if (!isNaN(current) && current > 0) {
              text.setAttribute("font-size", (current * 0.8).toFixed(2));
            }
          }
        });
        svg.querySelectorAll("text").forEach((text) => {
          const content = (text.textContent || "").trim();
          const match = content.match(/^Jupiter Original\s+Level\s+(1|2)$/);
          if (match) {
            text.textContent = `Jupiter Original - Level ${match[1]}`;
          }
        });
        const shrinkSpec = WAYFINDING_SHRINK_SPEC;
        svg.querySelectorAll("text").forEach((text) => {
          const content = (text.textContent || "").replace(/\s+/g, " ").trim();
          if (!content) return;
          const spec = shrinkSpec.find((entry) => entry.rx.test(content));
          if (!spec) return;
          text.removeAttribute("textLength");
          text.removeAttribute("lengthAdjust");
          text.setAttribute("font-size", String(spec.fs));
        });
        constrainTextMatches(svg, WAYFINDING_MATCHERS);
      }

      function constrainTextMatches(svg, regexps) {
        const texts = svg.querySelectorAll("text");
        texts.forEach((text) => {
          const full = (text.textContent || "").replace(/\s+/g, " ").trim();
          if (!full || !regexps.some((rx) => rx.test(full))) return;
          const group = text.closest("g");
          let box = null;
          try {
            const shapes = group ? group.querySelectorAll("rect, path, polygon, polyline, circle, ellipse") : [];
            shapes.forEach((shape) => {
              const b = shape.getBBox();
              if (!box) {
                box = { x: b.x, y: b.y, width: b.width, height: b.height };
              } else {
                const x1 = Math.min(box.x, b.x);
                const y1 = Math.min(box.y, b.y);
                const x2 = Math.max(box.x + box.width, b.x + b.width);
                const y2 = Math.max(box.y + box.height, b.y + b.height);
                box = { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };
              }
            });
            if (!box) box = text.getBBox();
          } catch (_) {
            return;
          }
          if (!box) return;
          const maxW = box.width * 0.92;
          const maxH = box.height * 0.85;
          const lines = text.querySelectorAll("tspan").length || 1;
          const fsCap = Math.max(3, maxH / lines);
          let currentFs = parseFloat(text.getAttribute("font-size") || window.getComputedStyle(text).fontSize) || fsCap;
          let newFs = Math.min(currentFs, fsCap);
          text.setAttribute("font-size", newFs.toFixed(2));
          text.removeAttribute("textLength");
          text.removeAttribute("lengthAdjust");
          let b1;
          try { b1 = text.getBBox(); } catch (_) { return; }
          if (b1.width > maxW) {
            text.setAttribute("lengthAdjust", "spacingAndGlyphs");
            text.setAttribute("textLength", maxW.toFixed(2));
          }
          if (b1.height > maxH) {
            const scale = maxH / b1.height;
            newFs = Math.max(3, newFs * scale);
            text.setAttribute("font-size", newFs.toFixed(2));
          }
        });
      }

      function matchVisualLabelSize(svg, refKey) {
        const tryMatch = () => {
          const layer = svg.querySelector("#label-layer");
          if (!layer) return false;
          const ref =
            layer.querySelector(`text[data-shape-key="${cssEscape(refKey)}"]`) ||
            layer.querySelector(`text[data-shape-label="${cssEscape(refKey)}"]`);
          if (!ref) return false;
          let refHeight;
          try {
            refHeight = ref.getBBox().height;
          } catch (_) {
            return false;
          }
          if (!refHeight) return false;
          const targets = [/^Stage$/i, /^Dream\s*Box$/i, /^Think\s*Tank$/i, /^Command\s*Center$/i];
          svg.querySelectorAll("text").forEach((text) => {
            const content = (text.textContent || "").trim();
            if (!targets.some((rx) => rx.test(content))) return;
            try {
              const group = text.closest("g");
              const groupBox = group && group.getBBox ? group.getBBox() : null;
              const textBox = text.getBBox();
              const scale = refHeight / textBox.height;
              const fsNow = parseFloat(text.getAttribute("font-size") || window.getComputedStyle(text).fontSize) || 6;
              const newFs = Math.max(2, Math.min(fsNow * scale, 7));
              text.setAttribute("font-size", newFs.toFixed(2));
              if (groupBox) {
                const maxW = groupBox.width * 0.9;
                const b = text.getBBox();
                if (b.width > maxW) {
                  text.setAttribute("lengthAdjust", "spacingAndGlyphs");
                  text.setAttribute("textLength", maxW.toFixed(2));
                }
              }
            } catch (_) {
              // ignore measurement errors
            }
          });
          return true;
        };
        if (!tryMatch()) setTimeout(tryMatch, 250);
      }

      function addCustomOverlayLabels(svg) {
        const layer = svg.querySelector("#label-layer");
        if (!layer) return;
        CUSTOM_LABEL_MAP.forEach((display, id) => {
          const node = svg.querySelector("#" + cssEscape(id)) || svg.querySelector(`[data-name="${cssEscape(id)}"]`);
          if (!node) return;
          appendLabel(node, display.replace(/\s+/g, " ").trim(), id);
          if (display.indexOf("\n") !== -1) {
            const textNode = layer.querySelector(`text[data-shape-key="${cssEscape(id)}"]`);
            if (!textNode) return;
            const fontSize = parseFloat(textNode.getAttribute("font-size") || "0") || 6;
            const bbox = node.getBBox();
            const lines = display.split("\n").map((line) => line.trim());
            while (textNode.firstChild) textNode.removeChild(textNode.firstChild);
            const totalHeight = fontSize * lines.length * 1.15;
            const startY = bbox.y + bbox.height / 2 - totalHeight / 2 + fontSize * 0.9;
            textNode.setAttribute("y", startY.toFixed(2));
            textNode.setAttribute("dominant-baseline", "alphabetic");
            lines.forEach((line, index) => {
              const tspan = document.createElementNS(SVG_NS, "tspan");
              if (index > 0) {
                tspan.setAttribute("x", textNode.getAttribute("x"));
                tspan.setAttribute("dy", (fontSize * 1.15).toFixed(2));
              }
              tspan.textContent = line;
              textNode.appendChild(tspan);
            });
          }
        });
      }
    })();
  </script>
</body>
</html>
